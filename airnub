#!/usr/bin/env bash
set -euo pipefail

resolve_script_dir() {
  local source="${BASH_SOURCE[0]}"
  while [[ -h "$source" ]]; do
    local dir
    dir="$(cd -P "$(dirname "$source")" && pwd)"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source"
  done

  local resolved_dir
  resolved_dir="$(cd -P "$(dirname "$source")" && pwd)"
  printf '%s\n' "$resolved_dir"
}

SCRIPT_DIR="$(resolve_script_dir)"
REPO_ROOT="$SCRIPT_DIR"
SUPABASE_DIR="${SUPABASE_DIR:-${REPO_ROOT}/supabase}"
DB_ENV_HELPER="${DB_ENV_HELPER:-${SUPABASE_DIR}/scripts/db-env-local.sh}"
CURRENT_PROJECT_FILE="${CURRENT_PROJECT_FILE:-${REPO_ROOT}/.airnub-current-project}"

usage() {
  cat <<'USAGE'
Usage: airnub <command> [subcommand] [options]

Commands:
  db env diff         Compare Supabase CLI env output with supabase/.env.local.
  db env sync         Refresh supabase/.env.local (starting the stack if needed).
  db env clean        Remove the generated supabase/.env.local file.
  db apply            Apply migrations against the shared Supabase stack.
  db reset            Reset the shared Supabase stack for a project (destructive).
  db status           Show the shared Supabase stack status for a project.
  project env sync    Merge Supabase env vars into a project .env.local file.
  project env diff    Compare a project .env.local with the shared Supabase env vars.
  project env clean   Remove the generated project .env.local file.
  project use         Sync env vars, run migrations, and show status for a project.
  project setup       Prime a project's .env.local from .env.example and Supabase vars.
  project current     Display the last project used with `project use`.
  project clean       Clear the remembered project selection.
  use                 Shortcut for `project use`.

Global options:
  -h, --help          Show this help message.

Use "airnub <command> --help" for more information on a command.
USAGE
}

db_env_usage() {
  cat <<'USAGE'
Usage: airnub db env <subcommand> [options]

Subcommands:
  diff                Compare Supabase CLI env output with supabase/.env.local.
  sync                Capture Supabase env vars into supabase/.env.local.
  clean               Remove supabase/.env.local.

Common options:
  --project-dir DIR   Supabase project directory (default: supabase/).
  --env-file PATH     Override the env file path (default: <project>/.env.local).
  -h, --help          Show this help message.

Additional diff options:
  --project-ref REF   Override the Supabase project ref used for CLI calls.

Additional sync options:
  --status-only       Only refresh env vars if Supabase is already running.
  --ensure-start      Start Supabase before syncing env vars.

Examples:
  airnub db env diff
  airnub db env sync --ensure-start
  airnub db env clean --env-file ./custom/.env.local
USAGE
}

project_env_usage() {
  cat <<'USAGE'
Usage: airnub project env <subcommand> [options]

Subcommands:
  sync                Merge supabase/.env.local into a project .env.local file.
  diff                Show differences between supabase/.env.local and a project env file.
  clean               Remove the generated project env file.

Common options:
  --project-dir DIR   Project directory (default: remembered project).
  --env-file PATH     Override the project .env.local path.
  -h, --help          Show this help message.

Additional sync options:
  --status-only       Only refresh shared env vars if Supabase is already running.
  --ensure-start      Start Supabase before refreshing shared env vars.

Examples:
  airnub project env diff --project-dir apps/my-app
  airnub project env sync --project-dir apps/my-app
  airnub project env clean --project-dir apps/my-app
USAGE
}

db_usage() {
  cat <<'USAGE'
Usage: airnub db <subcommand> [options] [-- <supabase args>]

Subcommands:
  env <subcommand>    Manage supabase/.env.local credentials (run with `--help` for details).
  apply               Apply migrations for the shared Supabase stack (alias: switch).
  reset               Reset the shared Supabase stack (destructive).
  status              Show shared Supabase stack details.

Options:
  --project-dir DIR       Supabase project directory (default: supabase/).
  --project-env-file PATH Override the project .env.local location.
  --project-ref REF       Override the Supabase project ref.
  --skip-env-sync         Do not refresh shared env vars before running the command.
  --ensure-env-sync       Force starting Supabase when refreshing env vars.
  --status-only-env-sync  Only refresh env vars if Supabase is already running.
  -h, --help              Show this help message.

All arguments after "--" are passed directly to the Supabase CLI for the selected subcommand.
USAGE
}

project_usage() {
  cat <<'USAGE'
Usage: airnub project <subcommand> [options]

Subcommands:
  env                 Manage project .env.local files based on Supabase credentials.
  use                 Sync env vars, apply migrations, and show status for a project.
  setup               Seed .env.local from .env.example (or append missing keys) and sync Supabase vars.
  current             Show the most recent project selected with `project use`.
  clean               Forget the remembered project selection.

Run "airnub project <subcommand> --help" for more details.
USAGE
}

project_use_usage() {
  cat <<'USAGE'
Usage: airnub project use [options] [<project-dir>]

Options:
  --skip-status        Skip the final `supabase status` confirmation step.

Examples:
  airnub project use ./million-dollar-maps
  airnub use                     # reuse the last project (or default supabase/)
  airnub use ./million-dollar-maps
USAGE
}

project_setup_usage() {
  cat <<'USAGE'
Usage: airnub project setup [options] [<project-dir>]

Options:
  --project-dir DIR   Explicit project directory (overrides remembered selection).
  --skip-env-sync     Skip the Supabase env sync step (only manage .env files).
  --help, -h          Show this help message.

Without --project-dir, the command uses the project last selected via
`airnub project use`. It copies <project>/.env.example to <project>/.env.local
when the destination does not exist, appends any missing keys from the example,
then runs `airnub project env sync` to refresh Supabase credentials.
USAGE
}

project_current_usage() {
  cat <<'USAGE'
Usage: airnub project current

Shows the project directory that was last activated with `airnub project use`.
USAGE
}

project_clean_usage() {
  cat <<'USAGE'
Usage: airnub project clean

Clears the remembered project selection so the next `airnub project use`
invocation requires an explicit directory (or falls back to defaults).
USAGE
}

die() {
  echo "[airnub] $*" >&2
  exit 1
}

warn() {
  echo "[airnub] $*" >&2
}

ensure_supabase_cli() {
  if ! command -v supabase >/dev/null 2>&1; then
    die "Supabase CLI not found on PATH. Install it inside the workspace container."
  fi
}

run_db_env_helper() {
  local behavior="$1"
  local project_dir="${2:-}"
  local env_file="${3:-}"

  if [[ ! -x "$DB_ENV_HELPER" ]]; then
    return 1
  fi

  local resolved_dir="$project_dir"
  if [[ -z "$resolved_dir" ]]; then
    resolved_dir="$SUPABASE_DIR"
  fi

  local -a helper_cmd=("$DB_ENV_HELPER")
  case "$behavior" in
    status-only)
      helper_cmd+=(--status-only)
      ;;
    ensure-start)
      helper_cmd+=(--ensure-start)
      ;;
    *)
      die "Unknown db-env helper mode: $behavior"
      ;;
  esac

  if [[ -n "$env_file" ]]; then
    helper_cmd+=(--env-file "$env_file")
  fi

  if [[ -n "$project_dir" ]]; then
    helper_cmd+=(--project-dir "$project_dir")
  fi

  local resolved_ref
  resolved_ref="$(get_shared_project_ref)"

  local -a helper_env=("SUPABASE_PROJECT_DIR=$resolved_dir")
  if [[ -n "$resolved_ref" ]]; then
    helper_env+=("SUPABASE_PROJECT_REF=$resolved_ref")
  fi

  env "${helper_env[@]}" "${helper_cmd[@]}"
}

shared_env_file() {
  printf '%s\n' "${SUPABASE_DIR}/.env.local"
}

get_shared_project_ref() {
  local explicit="${1:-}"
  if [[ -n "$explicit" ]]; then
    printf '%s\n' "$explicit"
    return 0
  fi

  local env_ref="${SHARED_SUPABASE_PROJECT_REF:-${AIRNUB_SUPABASE_PROJECT_REF:-}}"
  if [[ -n "$env_ref" ]]; then
    printf '%s\n' "$env_ref"
    return 0
  fi

  local config="${SUPABASE_DIR}/config.toml"
  if [[ -f "$config" ]]; then
    awk -F '"' '/^project_id/ {print $2; exit}' "$config" 2>/dev/null || true
  fi
}

merge_shared_env_into_project() {
  local destination="$1"
  local source
  source="$(shared_env_file)"

  if [[ ! -f "$source" ]]; then
    warn "Shared Supabase env file missing at $source."
    return 1
  fi

  mkdir -p "$(dirname "$destination")"

  local tmp_env
  tmp_env="$(mktemp)"

  cp "$source" "$tmp_env"

  if [[ -s "$tmp_env" && $(tail -c1 "$tmp_env" 2>/dev/null) != $'\n' ]]; then
    echo >>"$tmp_env"
  fi

  declare -A shared_keys=()
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    local key
    key="${line%%=*}"
    key="${key%%[[:space:]]*}"
    if [[ -n "$key" ]]; then
      shared_keys["$key"]=1
    fi
  done <"$source"

  local legacy_keys=(
    SUPABASE_ANON_KEY
    SUPABASE_SERVICE_ROLE_KEY
  )

  for legacy_key in "${legacy_keys[@]}"; do
    shared_keys["$legacy_key"]=1
  done

  if [[ -f "$destination" ]]; then
    local -a custom_lines=()
    while IFS= read -r line || [[ -n "$line" ]]; do
      if [[ "$line" =~ ^[[:space:]]*$ ]]; then
        custom_lines+=("$line")
        continue
      fi

      if [[ "$line" =~ ^[[:space:]]*# ]]; then
        custom_lines+=("$line")
        continue
      fi

      local key
      key="${line%%=*}"
      key="${key%%[[:space:]]*}"

      if [[ -n "$key" && -n "${shared_keys[$key]+x}" ]]; then
        continue
      fi

      custom_lines+=("$line")
    done <"$destination"

    if ((${#custom_lines[@]} > 0)); then
      echo >>"$tmp_env"
      echo "# Project-specific environment variables (preserved)" >>"$tmp_env"
      for line in "${custom_lines[@]}"; do
        echo "$line" >>"$tmp_env"
      done
    fi
  fi

  mv "$tmp_env" "$destination"
  chmod 600 "$destination" 2>/dev/null || true
  echo "[airnub] Synced Supabase env vars to $destination (custom entries preserved)."
  return 0
}

sync_shared_env_into_project() {
  local ensure_mode="$1"
  local project_env_file="$2"

  if [[ -z "$project_env_file" ]]; then
    warn "Project env file path is empty; cannot sync Supabase credentials."
    return 1
  fi

  if [[ ! -x "$DB_ENV_HELPER" ]]; then
    warn "db-env helper not found at $DB_ENV_HELPER; skipping shared env refresh."
  else
    if ! run_db_env_helper status-only "$SUPABASE_DIR" >/dev/null 2>&1; then
      if [[ "$ensure_mode" == "true" ]]; then
        if ! run_db_env_helper ensure-start "$SUPABASE_DIR" >/dev/null 2>&1; then
          warn "Could not refresh Supabase env vars via db-env helper."
        fi
      else
        warn "Supabase stack does not appear to be running; env vars may be stale."
      fi
    fi
  fi

  merge_shared_env_into_project "$project_env_file"
}

relative_to_repo() {
  local path="$1"

  if [[ "$path" == "$REPO_ROOT" ]]; then
    printf '.'
    return
  fi

  if [[ "$path" == "$REPO_ROOT"/* ]]; then
    printf './%s' "${path#$REPO_ROOT/}"
    return
  fi

  printf '%s' "$path"
}

remember_project() {
  local project_dir="$1"
  local output

  output="$(relative_to_repo "$project_dir")"

  mkdir -p "$(dirname "$CURRENT_PROJECT_FILE")"
  printf '%s\n' "$output" >"$CURRENT_PROJECT_FILE"
}

show_current_project() {
  if [[ -f "$CURRENT_PROJECT_FILE" ]]; then
    printf 'Last project used: %s\n' "$(<"$CURRENT_PROJECT_FILE")"
  else
    echo "No project has been selected yet. Run 'airnub project use <dir>' first."
  fi
}

get_current_project_dir() {
  if [[ ! -f "$CURRENT_PROJECT_FILE" ]]; then
    return 1
  fi

  local stored
  stored="$(<"$CURRENT_PROJECT_FILE")"
  stored="${stored//$'\r'/}"
  stored="${stored//$'\n'/}"

  if [[ -z "$stored" ]]; then
    return 1
  fi

  if [[ "$stored" == "." ]]; then
    printf '%s\n' "$REPO_ROOT"
    return 0
  fi

  if [[ "$stored" == /* ]]; then
    resolve_dir "$stored"
    return 0
  fi

  local relative="$stored"
  relative="${relative#./}"
  resolve_dir "$REPO_ROOT/$relative"
}

resolve_dir() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Project directory path is empty"
  fi

  if [[ "$input" == /* ]]; then
    [[ -d "$input" ]] || die "Directory not found: $input"
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "$input" ]]; then
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "${REPO_ROOT}/$input" ]]; then
    (cd "${REPO_ROOT}/$input" && pwd)
    return
  fi

  die "Directory not found: $input"
}

resolve_path() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Path cannot be empty"
  fi

  python3 - "$REPO_ROOT" "$input" <<'PY'
import os
import sys

root, target = sys.argv[1], sys.argv[2]

if os.path.isabs(target):
    print(os.path.normpath(target))
else:
    print(os.path.normpath(os.path.join(root, target)))
PY
}

parse_db_env_sync_args() {
  local default_mode="$1"
  local allow_status_override="$2"
  local action_label="$3"
  local usage_func="$4"
  shift 4 || true

  ENV_HELPER_MODE="$default_mode"
  ENV_PROJECT_DIR=""
  ENV_ENV_FILE=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project-dir)
        [[ $# -lt 2 ]] && die "--project-dir requires a directory"
        ENV_PROJECT_DIR="$(resolve_dir "$2")"
        shift 2
        ;;
      --env-file)
        [[ $# -lt 2 ]] && die "--env-file requires a path"
        ENV_ENV_FILE="$(resolve_path "$2")"
        shift 2
        ;;
      --status-only)
        if [[ "$allow_status_override" != "true" ]]; then
          die "--status-only is not available for '${action_label}'"
        fi
        ENV_HELPER_MODE="status-only"
        shift
        ;;
      --ensure-start)
        ENV_HELPER_MODE="ensure-start"
        shift
        ;;
      --help|-h)
        "$usage_func"
        return 1
        ;;
      --)
        shift
        if [[ $# -gt 0 ]]; then
          die "Unexpected extra arguments for '${action_label}': $*"
        fi
        ;;
      *)
        die "Unknown option for '${action_label}': $1"
        ;;
    esac
  done

  ENV_EFFECTIVE_PROJECT_DIR="${ENV_PROJECT_DIR:-${SUPABASE_DIR}}"
  if [[ -n "$ENV_ENV_FILE" ]]; then
    ENV_TARGET_ENV_FILE="$ENV_ENV_FILE"
  else
    ENV_TARGET_ENV_FILE="$ENV_EFFECTIVE_PROJECT_DIR/.env.local"
  fi

  return 0
}

db_env_command() {
  local action="${1:-}"
  shift || true

  case "$action" in
    diff)
      local project_dir=""
      local env_file=""
      local project_ref=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --project-ref)
            [[ $# -lt 2 ]] && die "--project-ref requires a value"
            project_ref="$2"
            shift 2
            ;;
          --help|-h)
            db_env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub db env diff': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub db env diff': $1"
            ;;
        esac
      done

      ensure_supabase_cli

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"
      local target_env_file="${env_file:-${effective_project_dir}/.env.local}"

      local supabase_tmp
      supabase_tmp="$(mktemp)"

      local -a supabase_cmd=("supabase" "status" "--workdir" "$effective_project_dir" "-o" "env")
      local -a env_prefix=()
      local resolved_project_ref
      resolved_project_ref="$(get_shared_project_ref "$project_ref")"
      if [[ -n "$resolved_project_ref" ]]; then
        env_prefix+=("SUPABASE_PROJECT_REF=$resolved_project_ref")
      fi

      if ! (cd "$REPO_ROOT" && env "${env_prefix[@]}" "${supabase_cmd[@]}") >"$supabase_tmp"; then
        rm -f "$supabase_tmp"
        die "Failed to capture Supabase status env output."
      fi

      python3 - "$supabase_tmp" "$target_env_file" <<'PY'
import os
import sys

supabase_path, env_path = sys.argv[1:3]

def load_env(path):
    data = {}
    if not os.path.exists(path):
        return data
    with open(path, 'r', encoding='utf-8') as handle:
        for raw_line in handle:
            line = raw_line.strip()
            if not line or line.startswith('#') or '=' not in line:
                continue
            key, value = line.split('=', 1)
            data[key.strip()] = value.strip()
    return data

sup_env = load_env(supabase_path)
file_env = load_env(env_path)
all_keys = sorted(set(sup_env) | set(file_env))

diffs = []
for key in all_keys:
    sup_val = sup_env.get(key)
    file_val = file_env.get(key)
    if sup_val == file_val:
        continue
    if sup_val is None:
        diffs.append(f"- {key}={file_val}")
    elif file_val is None:
        diffs.append(f"+ {key}={sup_val}")
    else:
        diffs.append("~ {}\n    Supabase: {}\n    File: {}".format(key, sup_val, file_val))

file_exists = os.path.exists(env_path)

if not file_exists and not diffs:
    print(f"[airnub] {env_path} does not exist yet; 'airnub db env sync' would create it with {len(sup_env)} entries.")
elif not diffs:
    print(f"[airnub] {env_path} already matches Supabase status output.")
else:
    print(f"[airnub] Differences between Supabase status env output and {env_path}:")
    for entry in diffs:
        print(entry)

if not file_exists and sup_env and diffs:
    missing = [d for d in diffs if d.startswith('+ ')]
    if missing:
        print("[airnub] The env file is missing these Supabase values:")
        for entry in missing:
            print(entry)
PY

      rm -f "$supabase_tmp"
      ;;
    sync)
      if ! parse_db_env_sync_args ensure-start true "airnub db env sync" db_env_usage "$@"; then
        return 0
      fi

      [[ -x "$DB_ENV_HELPER" ]] || die "db-env helper not found at $DB_ENV_HELPER"

      if ! run_db_env_helper "$ENV_HELPER_MODE" "$ENV_EFFECTIVE_PROJECT_DIR" "$ENV_ENV_FILE"; then
        die "Failed to capture Supabase env vars via $DB_ENV_HELPER"
      fi

      if [[ "$ENV_HELPER_MODE" == "status-only" ]]; then
        echo "[airnub] Refreshed Supabase env vars from running stack into $ENV_TARGET_ENV_FILE."
      else
        echo "[airnub] Synced Supabase env vars into $ENV_TARGET_ENV_FILE (stack started if necessary)."
      fi
      ;;
    start)
      db_env_command sync --ensure-start "$@"
      ;;
    clean)
      local project_dir=""
      local env_file=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --help|-h)
            db_env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub db env clean': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub db env clean': $1"
            ;;
        esac
      done

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"
      local target_env_file="${env_file:-${effective_project_dir}/.env.local}"

      if [[ -f "$target_env_file" ]]; then
        rm -f "$target_env_file"
        echo "[airnub] Removed $target_env_file."
      else
        echo "[airnub] No env file to remove at $target_env_file."
      fi
      ;;
    --help|-h|"")
      db_env_usage
      ;;
    *)
      die "Unknown db env subcommand: ${action}"
      ;;
  esac
}

project_env_command() {
  local action="${1:-}"
  shift || true

  case "$action" in
    sync)
      local project_dir=""
      local env_file=""
      local ensure_mode="true"

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --status-only)
            ensure_mode="false"
            shift
            ;;
          --ensure-start)
            ensure_mode="true"
            shift
            ;;
          --help|-h)
            project_env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub project env sync': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub project env sync': $1"
            ;;
        esac
      done

      if [[ -z "$project_dir" ]]; then
        if ! project_dir="$(get_current_project_dir 2>/dev/null)"; then
          die "Project directory is required; pass --project-dir or run 'airnub project use <dir>' first."
        fi
      fi

      local target_env_file="${env_file:-${project_dir}/.env.local}"

      if ! sync_shared_env_into_project "$ensure_mode" "$target_env_file"; then
        die "Failed to merge Supabase env vars into $target_env_file; run 'airnub db env sync' first if needed."
      fi
      ;;
    diff)
      local project_dir=""
      local env_file=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --help|-h)
            project_env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub project env diff': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub project env diff': $1"
            ;;
        esac
      done

      if [[ -z "$project_dir" ]]; then
        if ! project_dir="$(get_current_project_dir 2>/dev/null)"; then
          die "Project directory is required; pass --project-dir or run 'airnub project use <dir>' first."
        fi
      fi

      local target_env_file="${env_file:-${project_dir}/.env.local}"
      local shared_file
      shared_file="$(shared_env_file)"

      if [[ ! -f "$shared_file" ]]; then
        die "Shared Supabase env file not found at $shared_file. Run 'airnub db env sync' first."
      fi

      python3 - "$shared_file" "$target_env_file" <<'PY'
import os
import sys

shared_path, project_path = sys.argv[1:3]

def load_env(path):
    data = {}
    if not os.path.exists(path):
        return data
    with open(path, 'r', encoding='utf-8') as handle:
        for raw_line in handle:
            line = raw_line.strip()
            if not line or line.startswith('#') or '=' not in line:
                continue
            key, value = line.split('=', 1)
            data[key.strip()] = value.strip()
    return data

shared_env = load_env(shared_path)
project_env = load_env(project_path)
all_keys = sorted(set(shared_env) | set(project_env))

diffs = []
for key in all_keys:
    shared_val = shared_env.get(key)
    project_val = project_env.get(key)
    if shared_val == project_val:
        continue
    if shared_val is None:
        diffs.append(f"- {key}={project_val}")
    elif project_val is None:
        diffs.append(f"+ {key}={shared_val}")
    else:
        diffs.append("~ {}\n    Supabase: {}\n    Project: {}".format(key, shared_val, project_val))

project_exists = os.path.exists(project_path)

if not project_exists and not diffs:
    print(f"[airnub] {project_path} does not exist yet; run 'airnub project env sync' to seed it.")
elif not diffs:
    print(f"[airnub] {project_path} already matches {shared_path}.")
else:
    print(f"[airnub] Differences between {shared_path} and {project_path}:")
    for entry in diffs:
        print(entry)

if not project_exists and shared_env and diffs:
    missing = [d for d in diffs if d.startswith('+ ')]
    if missing:
        print("[airnub] The project env file is missing these Supabase values:")
        for entry in missing:
            print(entry)
PY
      ;;
    clean)
      local project_dir=""
      local env_file=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --help|-h)
            project_env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub project env clean': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub project env clean': $1"
            ;;
        esac
      done

      if [[ -z "$project_dir" ]]; then
        if ! project_dir="$(get_current_project_dir 2>/dev/null)"; then
          die "Project directory is required; pass --project-dir or run 'airnub project use <dir>' first."
        fi
      fi

      local target_env_file="${env_file:-${project_dir}/.env.local}"

      if [[ -f "$target_env_file" ]]; then
        rm -f "$target_env_file"
        echo "[airnub] Removed $target_env_file."
      else
        echo "[airnub] No env file to remove at $target_env_file."
      fi
      ;;
    --help|-h|"")
      project_env_usage
      ;;
    *)
      die "Unknown project env subcommand: ${action}"
      ;;
  esac
}

db_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    env)
      db_env_command "$@"
      ;;
    apply|switch|reset|status)
      local ensure_mode="auto"
      local project_dir=""
      local project_env_file=""
      local project_ref=""
      local skip_env_sync="false"
      local -a cli_args=()

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --project-env-file)
            [[ $# -lt 2 ]] && die "--project-env-file requires a path"
            project_env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --project-ref)
            [[ $# -lt 2 ]] && die "--project-ref requires a value"
            project_ref="$2"
            shift 2
            ;;
          --skip-env-sync)
            skip_env_sync="true"
            shift
            ;;
          --ensure-env-sync)
            ensure_mode="true"
            shift
            ;;
          --status-only-env-sync)
            ensure_mode="false"
            shift
            ;;
          --help|-h)
            db_usage
            return 0
            ;;
          --)
            shift
            cli_args+=("$@")
            break
            ;;
          *)
            cli_args+=("$1")
            shift
            ;;
        esac
      done

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"

      if [[ "$ensure_mode" == "auto" ]]; then
        case "$action" in
          apply|switch|reset)
            ensure_mode="true"
            ;;
          status)
            ensure_mode="false"
            ;;
        esac
      fi

      ensure_supabase_cli

      local target_env_file="$project_env_file"
      if [[ -z "$target_env_file" ]]; then
        target_env_file="$effective_project_dir/.env.local"
      fi

      local should_sync_env="true"
      if [[ "$action" == "status" && "$ensure_mode" == "false" ]]; then
        should_sync_env="false"
      fi

      if [[ "$skip_env_sync" != "true" ]]; then
        if [[ "$should_sync_env" == "true" ]]; then
          if ! sync_shared_env_into_project "$ensure_mode" "$target_env_file"; then
            warn "Continuing with '$action' even though env sync failed."
          fi
        elif [[ "$action" == "status" ]]; then
          echo "[airnub] Skipping env file refresh for status; run 'airnub project env sync' if you need updated credentials."
        fi
      else
        echo "[airnub] Skipping shared env refresh before $action (--skip-env-sync)."
      fi

      local workspace_root="$REPO_ROOT"
      local -a supabase_cmd=("supabase")
      local ref_for_log
      ref_for_log="$(get_shared_project_ref "$project_ref")"

      case "$action" in
        apply|switch)
          echo "[airnub] Applying migrations from $effective_project_dir via workspace $workspace_root${ref_for_log:+ (project ref: $ref_for_log)}."
          supabase_cmd+=(db push --workdir "$effective_project_dir" --local)
          ;;
        reset)
          echo "[airnub] WARNING: Resetting shared stack for $effective_project_dir via workspace $workspace_root. This wipes existing data."
          supabase_cmd+=(db reset --workdir "$effective_project_dir" --local)
          ;;
        status)
          echo "[airnub] Checking shared stack status for $effective_project_dir via workspace $workspace_root${ref_for_log:+ (project ref: $ref_for_log)}."
          supabase_cmd+=(status --workdir "$effective_project_dir")
          ;;
      esac

      if [[ "$action" == "switch" ]]; then
        echo "[airnub] 'db switch' is an alias for 'db apply'." >&2
      fi

      local -a env_prefix=()
      local resolved_project_ref
      resolved_project_ref="$(get_shared_project_ref "$project_ref")"
      if [[ -n "$resolved_project_ref" ]]; then
        env_prefix+=("SUPABASE_PROJECT_REF=$resolved_project_ref")
      fi

      if [[ "$action" == "reset" ]]; then
        local has_force=false
        for arg in "${cli_args[@]}"; do
          if [[ "$arg" == "-y" || "$arg" == "--no-confirm" ]]; then
            has_force=true
            break
          fi
        done
        if [[ "$has_force" != "true" ]]; then
          supabase_cmd+=(-y)
        fi
      fi

      supabase_cmd+=("${cli_args[@]}")

      (cd "$workspace_root" && env "${env_prefix[@]}" "${supabase_cmd[@]}")
      ;;
    --help|-h|"")
      db_usage
      ;;
    *)
      die "Unknown db subcommand: ${action}"
      ;;
  esac
}

project_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    env)
      project_env_command "$@"
      ;;
    use)
      local skip_status="false"
      local project_input=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --skip-status)
            skip_status="true"
            shift
            ;;
          --help|-h)
            project_use_usage
            return 0
            ;;
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            if [[ -n "$project_input" ]]; then
              die "Project directory already provided: $project_input"
            fi
            project_input="$2"
            shift 2
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments after '--': $*"
            fi
            ;;
          --*)
            die "Unknown option for 'airnub project use': $1"
            ;;
          *)
            if [[ -n "$project_input" ]]; then
              die "Multiple project directories provided: '$project_input' and '$1'"
            fi
            project_input="$1"
            shift
            ;;
        esac
      done

      local resolved_project=""
      local resolved_via=""

      if [[ -n "$project_input" ]]; then
        resolved_project="$(resolve_dir "$project_input")"
      else
        if resolved_project="$(get_current_project_dir 2>/dev/null)"; then
          resolved_via="remembered"
        elif [[ -d "$SUPABASE_DIR" ]]; then
          resolved_project="$(resolve_dir "$SUPABASE_DIR")"
          resolved_via="default"
        else
          die "Project directory is required and no default could be determined. See 'airnub project use --help'."
        fi
      fi

      if [[ "$resolved_via" == "remembered" ]]; then
        echo "[airnub] Using remembered project: $(relative_to_repo "$resolved_project")."
      elif [[ "$resolved_via" == "default" ]]; then
        echo "[airnub] No project supplied; defaulting to $(relative_to_repo "$resolved_project")."
      fi

      project_env_command sync --project-dir "$resolved_project"
      db_command apply --project-dir "$resolved_project"
      if [[ "$skip_status" != "true" ]]; then
        db_command status --project-dir "$resolved_project"
      fi

      remember_project "$resolved_project"
      show_current_project
      ;;
    setup)
      local project_input=""
      local skip_env_sync="false"

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            if [[ -n "$project_input" ]]; then
              die "Project directory already provided: $project_input"
            fi
            project_input="$2"
            shift 2
            ;;
          --skip-env-sync)
            skip_env_sync="true"
            shift
            ;;
          --help|-h)
            project_setup_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments after '--': $*"
            fi
            ;;
          --*)
            die "Unknown option for 'airnub project setup': $1"
            ;;
          *)
            if [[ -n "$project_input" ]]; then
              die "Multiple project directories provided: '$project_input' and '$1'"
            fi
            project_input="$1"
            shift
            ;;
        esac
      done

      local resolved_project=""
      if [[ -n "$project_input" ]]; then
        resolved_project="$(resolve_dir "$project_input")"
      else
        if ! resolved_project="$(get_current_project_dir)"; then
          die "No current project recorded. Use 'airnub project use <dir>' or supply --project-dir."
        fi
      fi

      local env_example="$resolved_project/.env.example"
      local env_local="$resolved_project/.env.local"

      if [[ -f "$env_example" ]]; then
        if [[ ! -f "$env_local" ]]; then
          cp "$env_example" "$env_local"
          echo "[airnub] Created $env_local from $env_example."
        else
          local appended_keys
          appended_keys="$(python3 - "$env_local" "$env_example" <<'PY'
import os
import sys

dest, example = sys.argv[1:3]

def load_keys(path):
    keys = {}
    if not os.path.exists(path):
        return keys
    with open(path, 'r', encoding='utf-8') as fh:
        for line in fh:
            stripped = line.strip()
            if not stripped or stripped.startswith('#'):
                continue
            if '=' not in line:
                continue
            key = line.split('=', 1)[0].strip()
            if key:
                keys.setdefault(key, line.rstrip('\n'))
    return keys

existing = load_keys(dest)
example_keys = load_keys(example)

missing = [k for k in example_keys.keys() if k not in existing]

if not missing:
    sys.exit(0)

needs_newline = False
if os.path.exists(dest) and os.path.getsize(dest) > 0:
    with open(dest, 'rb') as fh:
        fh.seek(-1, os.SEEK_END)
        needs_newline = fh.read(1) != b'\n'

with open(dest, 'a', encoding='utf-8') as fh:
    if needs_newline:
        fh.write('\n')
    for key in missing:
        fh.write(example_keys[key])
        fh.write('\n')

print('Added keys: ' + ', '.join(missing))
PY
)"
          if [[ -n "$appended_keys" ]]; then
            echo "[airnub] ${appended_keys}"
          else
            echo "[airnub] .env.local already contains keys from $env_example."
          fi
        fi
      else
        echo "[airnub] No .env.example found in $resolved_project; skipping example sync."
      fi

      if [[ "$skip_env_sync" != "true" ]]; then
        project_env_command sync --project-dir "$resolved_project"
      else
        echo "[airnub] Skipped Supabase env sync (per --skip-env-sync)."
      fi
      ;;
    clean)
      if [[ $# -gt 0 ]]; then
        case "$1" in
          --help|-h)
            project_clean_usage
            return 0
            ;;
          --*)
            die "Unknown option for 'airnub project clean': $1"
            ;;
          *)
            die "Unexpected argument for 'airnub project clean': $1"
            ;;
        esac
      fi

      if [[ -f "$CURRENT_PROJECT_FILE" ]]; then
        rm -f "$CURRENT_PROJECT_FILE"
        echo "[airnub] Cleared remembered project selection."
      else
        echo "[airnub] No remembered project selection to remove."
      fi
      ;;
    current)
      if [[ $# -gt 0 ]]; then
        case "$1" in
          --help|-h)
            project_current_usage
            return 0
            ;;
          *)
            die "Unknown option for 'airnub project current': $1"
            ;;
        esac
      fi
      show_current_project
      ;;
    --help|-h|"")
      project_usage
      ;;
    *)
      die "Unknown project subcommand: ${action}"
      ;;
  esac
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi

  local command="$1"
  shift

  case "$command" in
    db)
      db_command "$@"
      ;;
    project)
      project_command "$@"
      ;;
    env)
      die "'airnub env' has moved. Use 'airnub db env' for Supabase env management or 'airnub project env' for project env files."
      ;;
    use)
      project_command use "$@"
      ;;
    --help|-h)
      usage
      ;;
    *)
      die "Unknown command: $command"
      ;;
  esac
}

main "$@"
