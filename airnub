#!/usr/bin/env bash
set -euo pipefail

resolve_script_dir() {
  local source="${BASH_SOURCE[0]}"
  while [[ -h "$source" ]]; do
    local dir
    dir="$(cd -P "$(dirname "$source")" && pwd)"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source"
  done

  local resolved_dir
  resolved_dir="$(cd -P "$(dirname "$source")" && pwd)"
  printf '%s\n' "$resolved_dir"
}

SCRIPT_DIR="$(resolve_script_dir)"
REPO_ROOT="$SCRIPT_DIR"
SUPABASE_DIR="${SUPABASE_DIR:-${REPO_ROOT}/supabase}"
DB_ENV_HELPER="${DB_ENV_HELPER:-${SUPABASE_DIR}/scripts/db-env-local.sh}"
CURRENT_PROJECT_FILE="${CURRENT_PROJECT_FILE:-${REPO_ROOT}/.airnub-current-project}"
LEGACY_PROJECT_FILE="${LEGACY_PROJECT_FILE:-${SUPABASE_DIR}/.airnub-current-project}"

usage() {
  cat <<'USAGE'
Usage: airnub <command> [subcommand] [options]

Commands:
  env sync            Write Supabase env vars to a project .env.local file.
  env status          Refresh env vars only if the stack is already running.
  env start           Ensure the stack is running and emit env vars.
  env reset           Remove the generated env file for a project.
  db apply            Apply migrations against the shared Supabase stack.
  db reset            Reset the shared Supabase stack for a project (destructive).
  db status           Show the shared Supabase stack status for a project.
  project use         Sync env vars, run migrations, and show status for a project.
  project setup       Prime a project's .env.local from .env.example and Supabase vars.
  project current     Display the last project used with `project use`.
  use                 Shortcut for `project use`.

Global options:
  -h, --help          Show this help message.

Use "airnub <command> --help" for more information on a command.
USAGE
}

env_usage() {
  cat <<'USAGE'
Usage: airnub env <subcommand> [options]

Subcommands:
  sync                Write env vars, starting Supabase if needed (default behaviour).
  status              Only refresh env vars from a running Supabase stack.
  start               Ensure Supabase is running and then write env vars.
  reset               Remove the generated env file for a project.

Options:
  --project-dir DIR   Supabase project directory (default: supabase/).
  --env-file PATH     Destination for env vars (default: <project>/.env.local).
  --status-only       Equivalent to the `status` subcommand.
  --ensure-start      Force starting Supabase before syncing env vars.
  -h, --help          Show this help message.

  Examples:
  airnub env sync --project-dir apps/my-app
  airnub env status --env-file ./apps/my-app/.env.shared
  airnub env start  # alias for `env sync --ensure-start`
  airnub env reset --project-dir apps/my-app
USAGE
}

db_usage() {
  cat <<'USAGE'
Usage: airnub db <subcommand> [options] [-- <supabase args>]

Subcommands:
  apply               Apply migrations for the shared Supabase stack (alias: switch).
  reset               Reset the shared Supabase stack (destructive).
  status              Show shared Supabase stack details.

Options:
  --project-dir DIR       Supabase project directory (default: supabase/).
  --project-env-file PATH Override the project .env.local location.
  --project-ref REF       Override the Supabase project ref.
  --skip-env-sync         Do not refresh shared env vars before running the command.
  --ensure-env-sync       Force starting Supabase when refreshing env vars.
  --status-only-env-sync  Only refresh env vars if Supabase is already running.
  -h, --help              Show this help message.

All arguments after "--" are passed directly to the Supabase CLI for the selected subcommand.
USAGE
}

project_usage() {
  cat <<'USAGE'
Usage: airnub project <subcommand> [options]

Subcommands:
  use                 Sync env vars, apply migrations, and show status for a project.
  setup               Seed .env.local from .env.example (or append missing keys) and sync Supabase vars.
  current             Show the most recent project selected with `project use`.

Run "airnub project <subcommand> --help" for more details.
USAGE
}

project_use_usage() {
  cat <<'USAGE'
Usage: airnub project use [options] [<project-dir>]

Options:
  --skip-status        Skip the final `supabase status` confirmation step.

Examples:
  airnub project use ./million-dollar-maps
  airnub use                     # reuse the last project (or default supabase/)
  airnub use ./million-dollar-maps
USAGE
}

project_setup_usage() {
  cat <<'USAGE'
Usage: airnub project setup [options] [<project-dir>]

Options:
  --project-dir DIR   Explicit project directory (overrides remembered selection).
  --skip-env-sync     Skip the Supabase env sync step (only manage .env files).
  --help, -h          Show this help message.

Without --project-dir, the command uses the project last selected via
`airnub project use`. It copies <project>/.env.example to <project>/.env.local
when the destination does not exist, appends any missing keys from the example,
then runs `airnub env sync` to refresh Supabase credentials.
USAGE
}

project_current_usage() {
  cat <<'USAGE'
Usage: airnub project current

Shows the project directory that was last activated with `airnub project use`.
USAGE
}

die() {
  echo "[airnub] $*" >&2
  exit 1
}

warn() {
  echo "[airnub] $*" >&2
}

ensure_supabase_cli() {
  if ! command -v supabase >/dev/null 2>&1; then
    die "Supabase CLI not found on PATH. Install it inside the workspace container."
  fi
}

shared_env_file() {
  printf '%s\n' "${SUPABASE_DIR}/.env.local"
}

get_shared_project_ref() {
  if [[ -n "${1:-}" ]]; then
    printf '%s\n' "$1"
    return
  fi

  local config="${SUPABASE_DIR}/config.toml"
  if [[ -f "$config" ]]; then
    awk -F '"' '/^project_id/ {print $2; exit}' "$config" 2>/dev/null || true
  fi
}

merge_shared_env_into_project() {
  local destination="$1"
  local source
  source="$(shared_env_file)"

  if [[ ! -f "$source" ]]; then
    warn "Shared Supabase env file missing at $source."
    return 1
  fi

  mkdir -p "$(dirname "$destination")"

  local tmp_env
  tmp_env="$(mktemp)"

  cp "$source" "$tmp_env"

  if [[ -s "$tmp_env" && $(tail -c1 "$tmp_env" 2>/dev/null) != $'\n' ]]; then
    echo >>"$tmp_env"
  fi

  declare -A shared_keys=()
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    local key
    key="${line%%=*}"
    key="${key%%[[:space:]]*}"
    if [[ -n "$key" ]]; then
      shared_keys["$key"]=1
    fi
  done <"$source"

  local legacy_keys=(
    SUPABASE_ANON_KEY
    SUPABASE_SERVICE_ROLE_KEY
  )

  for legacy_key in "${legacy_keys[@]}"; do
    shared_keys["$legacy_key"]=1
  done

  if [[ -f "$destination" ]]; then
    local -a custom_lines=()
    while IFS= read -r line || [[ -n "$line" ]]; do
      if [[ "$line" =~ ^[[:space:]]*$ ]]; then
        custom_lines+=("$line")
        continue
      fi

      if [[ "$line" =~ ^[[:space:]]*# ]]; then
        custom_lines+=("$line")
        continue
      fi

      local key
      key="${line%%=*}"
      key="${key%%[[:space:]]*}"

      if [[ -n "$key" && -n "${shared_keys[$key]+x}" ]]; then
        continue
      fi

      custom_lines+=("$line")
    done <"$destination"

    if ((${#custom_lines[@]} > 0)); then
      echo >>"$tmp_env"
      echo "# Project-specific environment variables (preserved)" >>"$tmp_env"
      for line in "${custom_lines[@]}"; do
        echo "$line" >>"$tmp_env"
      done
    fi
  fi

  mv "$tmp_env" "$destination"
  chmod 600 "$destination" 2>/dev/null || true
  echo "[airnub] Synced Supabase env vars to $destination (custom entries preserved)."
  return 0
}

sync_shared_env_into_project() {
  local ensure_mode="$1"
  local project_env_file="$2"

  if [[ -z "$project_env_file" ]]; then
    warn "Project env file path is empty; cannot sync Supabase credentials."
    return 1
  fi

  if [[ ! -x "$DB_ENV_HELPER" ]]; then
    warn "db-env helper not found at $DB_ENV_HELPER; skipping shared env refresh."
  else
    if ! SUPABASE_PROJECT_DIR="$SUPABASE_DIR" "$DB_ENV_HELPER" --status-only >/dev/null 2>&1; then
      if [[ "$ensure_mode" == "true" ]]; then
        if ! SUPABASE_PROJECT_DIR="$SUPABASE_DIR" "$DB_ENV_HELPER" --ensure-start >/dev/null 2>&1; then
          warn "Could not refresh Supabase env vars via db-env helper."
        fi
      else
        warn "Supabase stack does not appear to be running; env vars may be stale."
      fi
    fi
  fi

  merge_shared_env_into_project "$project_env_file"
}

ensure_current_project_marker() {
  if [[ -f "$CURRENT_PROJECT_FILE" ]]; then
    return 0
  fi

  if [[ -n "${LEGACY_PROJECT_FILE:-}" && "$LEGACY_PROJECT_FILE" != "$CURRENT_PROJECT_FILE" && -f "$LEGACY_PROJECT_FILE" ]]; then
    mkdir -p "$(dirname "$CURRENT_PROJECT_FILE")"
    cp "$LEGACY_PROJECT_FILE" "$CURRENT_PROJECT_FILE"
    rm -f "$LEGACY_PROJECT_FILE"
    return 0
  fi

  return 1
}

relative_to_repo() {
  local path="$1"

  if [[ "$path" == "$REPO_ROOT" ]]; then
    printf '.'
    return
  fi

  if [[ "$path" == "$REPO_ROOT"/* ]]; then
    printf './%s' "${path#$REPO_ROOT/}"
    return
  fi

  printf '%s' "$path"
}

remember_project() {
  local project_dir="$1"
  local output

  output="$(relative_to_repo "$project_dir")"

  ensure_current_project_marker || true
  mkdir -p "$(dirname "$CURRENT_PROJECT_FILE")"
  printf '%s\n' "$output" >"$CURRENT_PROJECT_FILE"

  if [[ -n "${LEGACY_PROJECT_FILE:-}" && "$LEGACY_PROJECT_FILE" != "$CURRENT_PROJECT_FILE" ]]; then
    rm -f "$LEGACY_PROJECT_FILE"
  fi
}

show_current_project() {
  ensure_current_project_marker || true
  if [[ -f "$CURRENT_PROJECT_FILE" ]]; then
    printf 'Last project used: %s\n' "$(<"$CURRENT_PROJECT_FILE")"
  else
    echo "No project has been selected yet. Run 'airnub project use <dir>' first."
  fi
}

get_current_project_dir() {
  ensure_current_project_marker || true
  if [[ ! -f "$CURRENT_PROJECT_FILE" ]]; then
    return 1
  fi

  local stored
  stored="$(<"$CURRENT_PROJECT_FILE")"
  stored="${stored//$'\r'/}"
  stored="${stored//$'\n'/}"

  if [[ -z "$stored" ]]; then
    return 1
  fi

  if [[ "$stored" == "." ]]; then
    printf '%s\n' "$REPO_ROOT"
    return 0
  fi

  if [[ "$stored" == /* ]]; then
    resolve_dir "$stored"
    return 0
  fi

  local relative="$stored"
  relative="${relative#./}"
  resolve_dir "$REPO_ROOT/$relative"
}

resolve_dir() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Project directory path is empty"
  fi

  if [[ "$input" == /* ]]; then
    [[ -d "$input" ]] || die "Directory not found: $input"
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "$input" ]]; then
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "${REPO_ROOT}/$input" ]]; then
    (cd "${REPO_ROOT}/$input" && pwd)
    return
  fi

  die "Directory not found: $input"
}

resolve_path() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Path cannot be empty"
  fi

  python3 - "$REPO_ROOT" "$input" <<'PY'
import os
import sys

root, target = sys.argv[1], sys.argv[2]

if os.path.isabs(target):
    print(os.path.normpath(target))
else:
    print(os.path.normpath(os.path.join(root, target)))
PY
}

env_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    sync|status|start)
      local ensure_start="true"
      local status_only="false"
      local project_dir=""
      local env_file=""

      case "$action" in
        status)
          ensure_start="false"
          status_only="true"
          ;;
        start)
          ensure_start="true"
          ;;
      esac

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --status-only)
            ensure_start="false"
            status_only="true"
            shift
            ;;
          --ensure-start)
            ensure_start="true"
            status_only="false"
            shift
            ;;
          --help|-h)
            env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub env $action': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub env $action': $1"
            ;;
        esac
      done

      [[ -x "$DB_ENV_HELPER" ]] || die "db-env helper not found at $DB_ENV_HELPER"

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"
      local target_env_file="${env_file:-${effective_project_dir}/.env.local}"
      local -a cmd=("$DB_ENV_HELPER")

      if [[ "$status_only" == "true" ]]; then
        cmd+=("--status-only")
      else
        cmd+=("--ensure-start")
      fi

      if [[ -n "$env_file" ]]; then
        cmd+=("--env-file" "$env_file")
      fi

      if [[ -n "$project_dir" ]]; then
        cmd+=("--project-dir" "$project_dir")
      fi

      if SUPABASE_PROJECT_DIR="$effective_project_dir" "${cmd[@]}"; then
        if [[ "$status_only" == "true" ]]; then
          echo "[airnub] Refreshed Supabase env vars from running stack into $target_env_file."
        else
          echo "[airnub] Synced Supabase env vars into $target_env_file (stack started if necessary)."
        fi
      fi
      ;;
    reset)
      local project_dir=""
      local env_file=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --help|-h)
            env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub env reset': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub env reset': $1"
            ;;
        esac
      done

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"
      local target_env_file="${env_file:-${effective_project_dir}/.env.local}"

      if [[ -f "$target_env_file" ]]; then
        rm -f "$target_env_file"
        echo "[airnub] Removed $target_env_file."
      else
        echo "[airnub] No env file to remove at $target_env_file."
      fi
      ;;
    --help|-h|"")
      env_usage
      ;;
    *)
      die "Unknown env subcommand: ${action}"
      ;;
  esac
}

db_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    apply|switch|reset|status)
      local ensure_mode="auto"
      local project_dir=""
      local project_env_file=""
      local project_ref=""
      local skip_env_sync="false"
      local -a cli_args=()

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --project-env-file)
            [[ $# -lt 2 ]] && die "--project-env-file requires a path"
            project_env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --project-ref)
            [[ $# -lt 2 ]] && die "--project-ref requires a value"
            project_ref="$2"
            shift 2
            ;;
          --skip-env-sync)
            skip_env_sync="true"
            shift
            ;;
          --ensure-env-sync)
            ensure_mode="true"
            shift
            ;;
          --status-only-env-sync)
            ensure_mode="false"
            shift
            ;;
          --help|-h)
            db_usage
            return 0
            ;;
          --)
            shift
            cli_args+=("$@")
            break
            ;;
          *)
            cli_args+=("$1")
            shift
            ;;
        esac
      done

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"

      if [[ "$ensure_mode" == "auto" ]]; then
        case "$action" in
          apply|switch|reset)
            ensure_mode="true"
            ;;
          status)
            ensure_mode="false"
            ;;
        esac
      fi

      ensure_supabase_cli

      local target_env_file="$project_env_file"
      if [[ -z "$target_env_file" ]]; then
        target_env_file="$effective_project_dir/.env.local"
      fi

      if [[ "$skip_env_sync" != "true" ]]; then
        if ! sync_shared_env_into_project "$ensure_mode" "$target_env_file"; then
          warn "Continuing with '$action' even though env sync failed."
        fi
      else
        echo "[airnub] Skipping shared env refresh before $action (--skip-env-sync)."
      fi

      local workspace_root="$REPO_ROOT"
      local -a supabase_cmd=("supabase")
      local ref_for_log
      ref_for_log="$(get_shared_project_ref "$project_ref")"

      case "$action" in
        apply|switch)
          echo "[airnub] Applying migrations from $effective_project_dir via workspace $workspace_root${ref_for_log:+ (project ref: $ref_for_log)}."
          supabase_cmd+=(db push --workdir "$effective_project_dir" --local)
          ;;
        reset)
          echo "[airnub] WARNING: Resetting shared stack for $effective_project_dir via workspace $workspace_root. This wipes existing data."
          supabase_cmd+=(db reset --workdir "$effective_project_dir" --local)
          ;;
        status)
          echo "[airnub] Checking shared stack status for $effective_project_dir via workspace $workspace_root${ref_for_log:+ (project ref: $ref_for_log)}."
          supabase_cmd+=(status -o env --workdir "$effective_project_dir")
          ;;
      esac

      if [[ "$action" == "switch" ]]; then
        echo "[airnub] 'db switch' is an alias for 'db apply'." >&2
      fi

      local -a env_prefix=()
      if [[ -n "$project_ref" ]]; then
        env_prefix+=("SUPABASE_PROJECT_REF=$project_ref")
      fi

      if [[ "$action" == "reset" ]]; then
        local has_force=false
        for arg in "${cli_args[@]}"; do
          if [[ "$arg" == "-y" || "$arg" == "--no-confirm" ]]; then
            has_force=true
            break
          fi
        done
        if [[ "$has_force" != "true" ]]; then
          supabase_cmd+=(-y)
        fi
      fi

      supabase_cmd+=("${cli_args[@]}")

      (cd "$workspace_root" && env "${env_prefix[@]}" "${supabase_cmd[@]}")
      ;;
    --help|-h|"")
      db_usage
      ;;
    *)
      die "Unknown db subcommand: ${action}"
      ;;
  esac
}

project_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    use)
      local skip_status="false"
      local project_input=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --skip-status)
            skip_status="true"
            shift
            ;;
          --help|-h)
            project_use_usage
            return 0
            ;;
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            if [[ -n "$project_input" ]]; then
              die "Project directory already provided: $project_input"
            fi
            project_input="$2"
            shift 2
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments after '--': $*"
            fi
            ;;
          --*)
            die "Unknown option for 'airnub project use': $1"
            ;;
          *)
            if [[ -n "$project_input" ]]; then
              die "Multiple project directories provided: '$project_input' and '$1'"
            fi
            project_input="$1"
            shift
            ;;
        esac
      done

      local resolved_project=""
      local resolved_via=""

      if [[ -n "$project_input" ]]; then
        resolved_project="$(resolve_dir "$project_input")"
      else
        if resolved_project="$(get_current_project_dir 2>/dev/null)"; then
          resolved_via="remembered"
        elif [[ -d "$SUPABASE_DIR" ]]; then
          resolved_project="$(resolve_dir "$SUPABASE_DIR")"
          resolved_via="default"
        else
          die "Project directory is required and no default could be determined. See 'airnub project use --help'."
        fi
      fi

      if [[ "$resolved_via" == "remembered" ]]; then
        echo "[airnub] Using remembered project: $(relative_to_repo "$resolved_project")."
      elif [[ "$resolved_via" == "default" ]]; then
        echo "[airnub] No project supplied; defaulting to $(relative_to_repo "$resolved_project")."
      fi

      env_command sync --project-dir "$resolved_project"
      db_command apply --project-dir "$resolved_project"
      if [[ "$skip_status" != "true" ]]; then
        db_command status --project-dir "$resolved_project"
      fi

      remember_project "$resolved_project"
      show_current_project
      ;;
    setup)
      local project_input=""
      local skip_env_sync="false"

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            if [[ -n "$project_input" ]]; then
              die "Project directory already provided: $project_input"
            fi
            project_input="$2"
            shift 2
            ;;
          --skip-env-sync)
            skip_env_sync="true"
            shift
            ;;
          --help|-h)
            project_setup_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments after '--': $*"
            fi
            ;;
          --*)
            die "Unknown option for 'airnub project setup': $1"
            ;;
          *)
            if [[ -n "$project_input" ]]; then
              die "Multiple project directories provided: '$project_input' and '$1'"
            fi
            project_input="$1"
            shift
            ;;
        esac
      done

      local resolved_project=""
      if [[ -n "$project_input" ]]; then
        resolved_project="$(resolve_dir "$project_input")"
      else
        if ! resolved_project="$(get_current_project_dir)"; then
          die "No current project recorded. Use 'airnub project use <dir>' or supply --project-dir."
        fi
      fi

      local env_example="$resolved_project/.env.example"
      local env_local="$resolved_project/.env.local"

      if [[ -f "$env_example" ]]; then
        if [[ ! -f "$env_local" ]]; then
          cp "$env_example" "$env_local"
          echo "[airnub] Created $env_local from $env_example."
        else
          local appended_keys
          appended_keys="$(python3 - "$env_local" "$env_example" <<'PY'
import os
import sys

dest, example = sys.argv[1:3]

def load_keys(path):
    keys = {}
    if not os.path.exists(path):
        return keys
    with open(path, 'r', encoding='utf-8') as fh:
        for line in fh:
            stripped = line.strip()
            if not stripped or stripped.startswith('#'):
                continue
            if '=' not in line:
                continue
            key = line.split('=', 1)[0].strip()
            if key:
                keys.setdefault(key, line.rstrip('\n'))
    return keys

existing = load_keys(dest)
example_keys = load_keys(example)

missing = [k for k in example_keys.keys() if k not in existing]

if not missing:
    sys.exit(0)

needs_newline = False
if os.path.exists(dest) and os.path.getsize(dest) > 0:
    with open(dest, 'rb') as fh:
        fh.seek(-1, os.SEEK_END)
        needs_newline = fh.read(1) != b'\n'

with open(dest, 'a', encoding='utf-8') as fh:
    if needs_newline:
        fh.write('\n')
    for key in missing:
        fh.write(example_keys[key])
        fh.write('\n')

print('Added keys: ' + ', '.join(missing))
PY
)"
          if [[ -n "$appended_keys" ]]; then
            echo "[airnub] ${appended_keys}"
          else
            echo "[airnub] .env.local already contains keys from $env_example."
          fi
        fi
      else
        echo "[airnub] No .env.example found in $resolved_project; skipping example sync."
      fi

      if [[ "$skip_env_sync" != "true" ]]; then
        env_command sync --project-dir "$resolved_project"
      else
        echo "[airnub] Skipped Supabase env sync (per --skip-env-sync)."
      fi
      ;;
    current)
      if [[ $# -gt 0 ]]; then
        case "$1" in
          --help|-h)
            project_current_usage
            return 0
            ;;
          *)
            die "Unknown option for 'airnub project current': $1"
            ;;
        esac
      fi
      show_current_project
      ;;
    --help|-h|"")
      project_usage
      ;;
    *)
      die "Unknown project subcommand: ${action}"
      ;;
  esac
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi

  local command="$1"
  shift

  case "$command" in
    env)
      env_command "$@"
      ;;
    db)
      db_command "$@"
      ;;
    project)
      project_command "$@"
      ;;
    use)
      project_command use "$@"
      ;;
    --help|-h)
      usage
      ;;
    *)
      die "Unknown command: $command"
      ;;
  esac
}

main "$@"
