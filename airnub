#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$SCRIPT_DIR"
SUPABASE_DIR="${SUPABASE_DIR:-${REPO_ROOT}/supabase}"
DB_ENV_HELPER="${DB_ENV_HELPER:-${SUPABASE_DIR}/scripts/db-env-local.sh}"
SHARED_SCRIPT="${SHARED_SCRIPT:-${SUPABASE_DIR}/scripts/use-shared-supabase.sh}"
CURRENT_PROJECT_FILE="${CURRENT_PROJECT_FILE:-${SUPABASE_DIR}/.airnub-current-project}"

usage() {
  cat <<'USAGE'
Usage: airnub <command> [subcommand] [options]

Commands:
  env sync            Write Supabase env vars to a project .env.local file.
  env status          Refresh env vars only if the stack is already running.
  env start           Ensure the stack is running and emit env vars.
  db apply            Apply migrations against the shared Supabase stack.
  db reset            Reset the shared Supabase stack for a project (destructive).
  db status           Show the shared Supabase stack status for a project.
  project use         Sync env vars, run migrations, and show status for a project.
  project current     Display the last project used with `project use`.
  use                 Shortcut for `project use`.

Global options:
  -h, --help          Show this help message.

Use "airnub <command> --help" for more information on a command.
USAGE
}

env_usage() {
  cat <<'USAGE'
Usage: airnub env <subcommand> [options]

Subcommands:
  sync                Write env vars, starting Supabase if needed (default behaviour).
  status              Only refresh env vars from a running Supabase stack.
  start               Ensure Supabase is running and then write env vars.

Options:
  --project-dir DIR   Supabase project directory (default: supabase/).
  --env-file PATH     Destination for env vars (default: <project>/.env.local).
  --status-only       Equivalent to the `status` subcommand.
  --ensure-start      Force starting Supabase before syncing env vars.
  -h, --help          Show this help message.

Examples:
  airnub env sync --project-dir apps/my-app
  airnub env status --env-file ./apps/my-app/.env.shared
  airnub env start  # alias for `env sync --ensure-start`
USAGE
}

db_usage() {
  cat <<'USAGE'
Usage: airnub db <subcommand> [options] [-- <supabase args>]

Subcommands:
  apply               Apply migrations for the shared Supabase stack (alias: switch).
  reset               Reset the shared Supabase stack (destructive).
  status              Show shared Supabase stack details.

Options:
  --project-dir DIR       Supabase project directory (default: supabase/).
  --project-env-file PATH Override the project .env.local location.
  --project-ref REF       Override the Supabase project ref.
  --skip-env-sync         Do not refresh shared env vars before running the command.
  --ensure-env-sync       Force starting Supabase when refreshing env vars.
  --status-only-env-sync  Only refresh env vars if Supabase is already running.
  -h, --help              Show this help message.

All arguments after "--" are passed directly to the Supabase CLI for the selected subcommand.
USAGE
}

project_usage() {
  cat <<'USAGE'
Usage: airnub project <subcommand> [options]

Subcommands:
  use                 Sync env vars, apply migrations, and show status for a project.
  current             Show the most recent project selected with `project use`.

Run "airnub project <subcommand> --help" for more details.
USAGE
}

project_use_usage() {
  cat <<'USAGE'
Usage: airnub project use [options] <project-dir>

Options:
  --skip-status        Skip the final `supabase status` confirmation step.

Examples:
  airnub project use ./million-dollar-maps
  airnub use ./million-dollar-maps
USAGE
}

project_current_usage() {
  cat <<'USAGE'
Usage: airnub project current

Shows the project directory that was last activated with `airnub project use`.
USAGE
}

die() {
  echo "[airnub] $*" >&2
  exit 1
}

remember_project() {
  local project_dir="$1"
  local output="$project_dir"

  if [[ "$project_dir" == "$REPO_ROOT" ]]; then
    output="."
  elif [[ "$project_dir" == "$REPO_ROOT"/* ]]; then
    local relative="${project_dir#$REPO_ROOT/}"
    output="./${relative}"
  fi

  mkdir -p "$(dirname "$CURRENT_PROJECT_FILE")"
  printf '%s\n' "$output" >"$CURRENT_PROJECT_FILE"
}

show_current_project() {
  if [[ -f "$CURRENT_PROJECT_FILE" ]]; then
    printf 'Last project used: %s\n' "$(<"$CURRENT_PROJECT_FILE")"
  else
    echo "No project has been selected yet. Run 'airnub project use <dir>' first."
  fi
}

resolve_dir() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Project directory path is empty"
  fi

  if [[ "$input" == /* ]]; then
    [[ -d "$input" ]] || die "Directory not found: $input"
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "$input" ]]; then
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "${REPO_ROOT}/$input" ]]; then
    (cd "${REPO_ROOT}/$input" && pwd)
    return
  fi

  die "Directory not found: $input"
}

resolve_path() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Path cannot be empty"
  fi

  python3 - "$REPO_ROOT" "$input" <<'PY'
import os
import sys

root, target = sys.argv[1], sys.argv[2]

if os.path.isabs(target):
    print(os.path.normpath(target))
else:
    print(os.path.normpath(os.path.join(root, target)))
PY
}

env_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    sync|status|start)
      local ensure_start="true"
      local status_only="false"
      local project_dir=""
      local env_file=""

      case "$action" in
        status)
          ensure_start="false"
          status_only="true"
          ;;
        start)
          ensure_start="true"
          ;;
      esac

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --status-only)
            ensure_start="false"
            status_only="true"
            shift
            ;;
          --ensure-start)
            ensure_start="true"
            status_only="false"
            shift
            ;;
          --help|-h)
            env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub env $action': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub env $action': $1"
            ;;
        esac
      done

      [[ -x "$DB_ENV_HELPER" ]] || die "db-env helper not found at $DB_ENV_HELPER"

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"
      local target_env_file="${env_file:-${effective_project_dir}/.env.local}"
      local -a cmd=("$DB_ENV_HELPER")

      if [[ "$status_only" == "true" ]]; then
        cmd+=("--status-only")
      else
        cmd+=("--ensure-start")
      fi

      if [[ -n "$env_file" ]]; then
        cmd+=("--env-file" "$env_file")
      fi

      if [[ -n "$project_dir" ]]; then
        cmd+=("--project-dir" "$project_dir")
      fi

      if SUPABASE_PROJECT_DIR="$effective_project_dir" "${cmd[@]}"; then
        if [[ "$status_only" == "true" ]]; then
          echo "[airnub] Refreshed Supabase env vars from running stack into $target_env_file."
        else
          echo "[airnub] Synced Supabase env vars into $target_env_file (stack started if necessary)."
        fi
      fi
      ;;
    --help|-h|"")
      env_usage
      ;;
    *)
      die "Unknown env subcommand: ${action}"
      ;;
  esac
}

run_shared_action() {
  local action="$1"
  local ensure_env_mode="$2"
  local project_dir="$3"
  local skip_env_sync="$4"
  local project_env_file="$5"
  local project_ref="$6"
  shift 6 || true

  [[ -x "$SHARED_SCRIPT" ]] || die "shared supabase helper not found at $SHARED_SCRIPT"

  local env_project_dir="${project_dir:-${SUPABASE_DIR}}"
  local -a env_prefix=("PROJECT_DIR=$env_project_dir")

  if [[ -n "$project_env_file" ]]; then
    env_prefix+=("PROJECT_ENV_FILE=$project_env_file")
  fi

  if [[ -n "$project_ref" ]]; then
    env_prefix+=("SUPABASE_PROJECT_REF=$project_ref")
  fi

  if [[ "$skip_env_sync" == "true" ]]; then
    env_prefix+=("SKIP_SHARED_ENV_SYNC=true")
  fi

  case "$ensure_env_mode" in
    true|false)
      env_prefix+=("SHARED_ENV_ENSURE_START=$ensure_env_mode")
      ;;
    auto)
      ;;
    *)
      die "Unknown env sync mode: $ensure_env_mode"
      ;;
  esac

  env "${env_prefix[@]}" "$SHARED_SCRIPT" "$action" "$@"
}

db_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    apply|switch|reset|status)
      local supabase_action=""
      local ensure_mode="auto"
      local project_dir=""
      local project_env_file=""
      local project_ref=""
      local skip_env_sync="false"
      local -a cli_args=()

      case "$action" in
        apply)
          supabase_action="push"
          ;;
        switch)
          supabase_action="push"
          echo "[airnub] 'db switch' is an alias for 'db apply'." >&2
          ;;
        reset)
          supabase_action="reset"
          ;;
        status)
          supabase_action="status"
          ;;
      esac

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --project-env-file)
            [[ $# -lt 2 ]] && die "--project-env-file requires a path"
            project_env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --project-ref)
            [[ $# -lt 2 ]] && die "--project-ref requires a value"
            project_ref="$2"
            shift 2
            ;;
          --skip-env-sync)
            skip_env_sync="true"
            shift
            ;;
          --ensure-env-sync)
            ensure_mode="true"
            shift
            ;;
          --status-only-env-sync)
            ensure_mode="false"
            shift
            ;;
          --help|-h)
            db_usage
            return 0
            ;;
          --)
            shift
            cli_args+=("$@")
            break
            ;;
          *)
            cli_args+=("$1")
            shift
            ;;
        esac
      done

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"

      if [[ "$ensure_mode" == "auto" ]]; then
        case "$action" in
          apply|switch|reset)
            ensure_mode="true"
            ;;
          status)
            ensure_mode="false"
            ;;
        esac
      fi

      run_shared_action "$supabase_action" "$ensure_mode" "$effective_project_dir" "$skip_env_sync" "$project_env_file" "$project_ref" "${cli_args[@]}"
      ;;
    --help|-h|"")
      db_usage
      ;;
    *)
      die "Unknown db subcommand: ${action}"
      ;;
  esac
}

project_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    use)
      local skip_status="false"
      local project_input=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --skip-status)
            skip_status="true"
            shift
            ;;
          --help|-h)
            project_use_usage
            return 0
            ;;
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            if [[ -n "$project_input" ]]; then
              die "Project directory already provided: $project_input"
            fi
            project_input="$2"
            shift 2
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments after '--': $*"
            fi
            ;;
          --*)
            die "Unknown option for 'airnub project use': $1"
            ;;
          *)
            if [[ -n "$project_input" ]]; then
              die "Multiple project directories provided: '$project_input' and '$1'"
            fi
            project_input="$1"
            shift
            ;;
        esac
      done

      if [[ -z "$project_input" ]]; then
        die "Project directory is required. See 'airnub project use --help'."
      fi

      local resolved_project
      resolved_project="$(resolve_dir "$project_input")"

      env_command sync --project-dir "$resolved_project"
      db_command apply --project-dir "$resolved_project"
      if [[ "$skip_status" != "true" ]]; then
        db_command status --project-dir "$resolved_project"
      fi

      remember_project "$resolved_project"
      show_current_project
      ;;
    current)
      if [[ $# -gt 0 ]]; then
        case "$1" in
          --help|-h)
            project_current_usage
            return 0
            ;;
          *)
            die "Unknown option for 'airnub project current': $1"
            ;;
        esac
      fi
      show_current_project
      ;;
    --help|-h|"")
      project_usage
      ;;
    *)
      die "Unknown project subcommand: ${action}"
      ;;
  esac
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi

  local command="$1"
  shift

  case "$command" in
    env)
      env_command "$@"
      ;;
    db)
      db_command "$@"
      ;;
    project)
      project_command "$@"
      ;;
    use)
      project_command use "$@"
      ;;
    --help|-h)
      usage
      ;;
    *)
      die "Unknown command: $command"
      ;;
  esac
}

main "$@"
