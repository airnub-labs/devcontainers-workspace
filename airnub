#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$SCRIPT_DIR"
SUPABASE_DIR="${SUPABASE_DIR:-${REPO_ROOT}/supabase}"
DB_ENV_HELPER="${DB_ENV_HELPER:-${SUPABASE_DIR}/scripts/db-env-local.sh}"
SHARED_SCRIPT="${SHARED_SCRIPT:-${SUPABASE_DIR}/scripts/use-shared-supabase.sh}"
CURRENT_PROJECT_FILE="${CURRENT_PROJECT_FILE:-${SUPABASE_DIR}/.airnub-current-project}"

usage() {
  cat <<'USAGE'
Usage: airnub <command> [subcommand] [options]

Commands:
  env sync            Write Supabase env vars to a project .env.local file.
  env status          Refresh env vars only if the stack is already running.
  env start           Ensure the stack is running and emit env vars.
  env reset           Remove the generated env file for a project.
  db apply            Apply migrations against the shared Supabase stack.
  db reset            Reset the shared Supabase stack for a project (destructive).
  db status           Show the shared Supabase stack status for a project.
  project use         Sync env vars, run migrations, and show status for a project.
  project setup       Prime a project's .env.local from .env.example and Supabase vars.
  project current     Display the last project used with `project use`.
  use                 Shortcut for `project use`.

Global options:
  -h, --help          Show this help message.

Use "airnub <command> --help" for more information on a command.
USAGE
}

env_usage() {
  cat <<'USAGE'
Usage: airnub env <subcommand> [options]

Subcommands:
  sync                Write env vars, starting Supabase if needed (default behaviour).
  status              Only refresh env vars from a running Supabase stack.
  start               Ensure Supabase is running and then write env vars.
  reset               Remove the generated env file for a project.

Options:
  --project-dir DIR   Supabase project directory (default: supabase/).
  --env-file PATH     Destination for env vars (default: <project>/.env.local).
  --status-only       Equivalent to the `status` subcommand.
  --ensure-start      Force starting Supabase before syncing env vars.
  -h, --help          Show this help message.

  Examples:
  airnub env sync --project-dir apps/my-app
  airnub env status --env-file ./apps/my-app/.env.shared
  airnub env start  # alias for `env sync --ensure-start`
  airnub env reset --project-dir apps/my-app
USAGE
}

db_usage() {
  cat <<'USAGE'
Usage: airnub db <subcommand> [options] [-- <supabase args>]

Subcommands:
  apply               Apply migrations for the shared Supabase stack (alias: switch).
  reset               Reset the shared Supabase stack (destructive).
  status              Show shared Supabase stack details.

Options:
  --project-dir DIR       Supabase project directory (default: supabase/).
  --project-env-file PATH Override the project .env.local location.
  --project-ref REF       Override the Supabase project ref.
  --skip-env-sync         Do not refresh shared env vars before running the command.
  --ensure-env-sync       Force starting Supabase when refreshing env vars.
  --status-only-env-sync  Only refresh env vars if Supabase is already running.
  -h, --help              Show this help message.

All arguments after "--" are passed directly to the Supabase CLI for the selected subcommand.
USAGE
}

project_usage() {
  cat <<'USAGE'
Usage: airnub project <subcommand> [options]

Subcommands:
  use                 Sync env vars, apply migrations, and show status for a project.
  setup               Seed .env.local from .env.example (or append missing keys) and sync Supabase vars.
  current             Show the most recent project selected with `project use`.

Run "airnub project <subcommand> --help" for more details.
USAGE
}

project_use_usage() {
  cat <<'USAGE'
Usage: airnub project use [options] <project-dir>

Options:
  --skip-status        Skip the final `supabase status` confirmation step.

Examples:
  airnub project use ./million-dollar-maps
  airnub use ./million-dollar-maps
USAGE
}

project_setup_usage() {
  cat <<'USAGE'
Usage: airnub project setup [options] [<project-dir>]

Options:
  --project-dir DIR   Explicit project directory (overrides remembered selection).
  --skip-env-sync     Skip the Supabase env sync step (only manage .env files).
  --help, -h          Show this help message.

Without --project-dir, the command uses the project last selected via
`airnub project use`. It copies <project>/.env.example to <project>/.env.local
when the destination does not exist, appends any missing keys from the example,
then runs `airnub env sync` to refresh Supabase credentials.
USAGE
}

project_current_usage() {
  cat <<'USAGE'
Usage: airnub project current

Shows the project directory that was last activated with `airnub project use`.
USAGE
}

die() {
  echo "[airnub] $*" >&2
  exit 1
}

remember_project() {
  local project_dir="$1"
  local output="$project_dir"

  if [[ "$project_dir" == "$REPO_ROOT" ]]; then
    output="."
  elif [[ "$project_dir" == "$REPO_ROOT"/* ]]; then
    local relative="${project_dir#$REPO_ROOT/}"
    output="./${relative}"
  fi

  mkdir -p "$(dirname "$CURRENT_PROJECT_FILE")"
  printf '%s\n' "$output" >"$CURRENT_PROJECT_FILE"
}

show_current_project() {
  if [[ -f "$CURRENT_PROJECT_FILE" ]]; then
    printf 'Last project used: %s\n' "$(<"$CURRENT_PROJECT_FILE")"
  else
    echo "No project has been selected yet. Run 'airnub project use <dir>' first."
  fi
}

get_current_project_dir() {
  if [[ ! -f "$CURRENT_PROJECT_FILE" ]]; then
    return 1
  fi

  local stored
  stored="$(<"$CURRENT_PROJECT_FILE")"
  stored="${stored//$'\r'/}"
  stored="${stored//$'\n'/}"

  if [[ -z "$stored" ]]; then
    return 1
  fi

  if [[ "$stored" == "." ]]; then
    printf '%s\n' "$REPO_ROOT"
    return 0
  fi

  if [[ "$stored" == /* ]]; then
    resolve_dir "$stored"
    return 0
  fi

  local relative="$stored"
  relative="${relative#./}"
  resolve_dir "$REPO_ROOT/$relative"
}

resolve_dir() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Project directory path is empty"
  fi

  if [[ "$input" == /* ]]; then
    [[ -d "$input" ]] || die "Directory not found: $input"
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "$input" ]]; then
    (cd "$input" && pwd)
    return
  fi

  if [[ -d "${REPO_ROOT}/$input" ]]; then
    (cd "${REPO_ROOT}/$input" && pwd)
    return
  fi

  die "Directory not found: $input"
}

resolve_path() {
  local input="$1"

  if [[ -z "$input" ]]; then
    die "Path cannot be empty"
  fi

  python3 - "$REPO_ROOT" "$input" <<'PY'
import os
import sys

root, target = sys.argv[1], sys.argv[2]

if os.path.isabs(target):
    print(os.path.normpath(target))
else:
    print(os.path.normpath(os.path.join(root, target)))
PY
}

env_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    sync|status|start)
      local ensure_start="true"
      local status_only="false"
      local project_dir=""
      local env_file=""

      case "$action" in
        status)
          ensure_start="false"
          status_only="true"
          ;;
        start)
          ensure_start="true"
          ;;
      esac

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --status-only)
            ensure_start="false"
            status_only="true"
            shift
            ;;
          --ensure-start)
            ensure_start="true"
            status_only="false"
            shift
            ;;
          --help|-h)
            env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub env $action': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub env $action': $1"
            ;;
        esac
      done

      [[ -x "$DB_ENV_HELPER" ]] || die "db-env helper not found at $DB_ENV_HELPER"

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"
      local target_env_file="${env_file:-${effective_project_dir}/.env.local}"
      local -a cmd=("$DB_ENV_HELPER")

      if [[ "$status_only" == "true" ]]; then
        cmd+=("--status-only")
      else
        cmd+=("--ensure-start")
      fi

      if [[ -n "$env_file" ]]; then
        cmd+=("--env-file" "$env_file")
      fi

      if [[ -n "$project_dir" ]]; then
        cmd+=("--project-dir" "$project_dir")
      fi

      if SUPABASE_PROJECT_DIR="$effective_project_dir" "${cmd[@]}"; then
        if [[ "$status_only" == "true" ]]; then
          echo "[airnub] Refreshed Supabase env vars from running stack into $target_env_file."
        else
          echo "[airnub] Synced Supabase env vars into $target_env_file (stack started if necessary)."
        fi
      fi
      ;;
    reset)
      local project_dir=""
      local env_file=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --env-file)
            [[ $# -lt 2 ]] && die "--env-file requires a path"
            env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --help|-h)
            env_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments for 'airnub env reset': $*"
            fi
            ;;
          *)
            die "Unknown option for 'airnub env reset': $1"
            ;;
        esac
      done

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"
      local target_env_file="${env_file:-${effective_project_dir}/.env.local}"

      if [[ -f "$target_env_file" ]]; then
        rm -f "$target_env_file"
        echo "[airnub] Removed $target_env_file."
      else
        echo "[airnub] No env file to remove at $target_env_file."
      fi
      ;;
    --help|-h|"")
      env_usage
      ;;
    *)
      die "Unknown env subcommand: ${action}"
      ;;
  esac
}

run_shared_action() {
  local action="$1"
  local ensure_env_mode="$2"
  local project_dir="$3"
  local skip_env_sync="$4"
  local project_env_file="$5"
  local project_ref="$6"
  shift 6 || true

  [[ -x "$SHARED_SCRIPT" ]] || die "shared supabase helper not found at $SHARED_SCRIPT"

  local env_project_dir="${project_dir:-${SUPABASE_DIR}}"
  local -a env_prefix=("PROJECT_DIR=$env_project_dir")

  if [[ -n "$project_env_file" ]]; then
    env_prefix+=("PROJECT_ENV_FILE=$project_env_file")
  fi

  if [[ -n "$project_ref" ]]; then
    env_prefix+=("SUPABASE_PROJECT_REF=$project_ref")
  fi

  if [[ "$skip_env_sync" == "true" ]]; then
    env_prefix+=("SKIP_SHARED_ENV_SYNC=true")
  fi

  case "$ensure_env_mode" in
    true|false)
      env_prefix+=("SHARED_ENV_ENSURE_START=$ensure_env_mode")
      ;;
    auto)
      ;;
    *)
      die "Unknown env sync mode: $ensure_env_mode"
      ;;
  esac

  env "${env_prefix[@]}" "$SHARED_SCRIPT" "$action" "$@"
}

db_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    apply|switch|reset|status)
      local supabase_action=""
      local ensure_mode="auto"
      local project_dir=""
      local project_env_file=""
      local project_ref=""
      local skip_env_sync="false"
      local -a cli_args=()

      case "$action" in
        apply)
          supabase_action="push"
          ;;
        switch)
          supabase_action="push"
          echo "[airnub] 'db switch' is an alias for 'db apply'." >&2
          ;;
        reset)
          supabase_action="reset"
          ;;
        status)
          supabase_action="status"
          ;;
      esac

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            project_dir="$(resolve_dir "$2")"
            shift 2
            ;;
          --project-env-file)
            [[ $# -lt 2 ]] && die "--project-env-file requires a path"
            project_env_file="$(resolve_path "$2")"
            shift 2
            ;;
          --project-ref)
            [[ $# -lt 2 ]] && die "--project-ref requires a value"
            project_ref="$2"
            shift 2
            ;;
          --skip-env-sync)
            skip_env_sync="true"
            shift
            ;;
          --ensure-env-sync)
            ensure_mode="true"
            shift
            ;;
          --status-only-env-sync)
            ensure_mode="false"
            shift
            ;;
          --help|-h)
            db_usage
            return 0
            ;;
          --)
            shift
            cli_args+=("$@")
            break
            ;;
          *)
            cli_args+=("$1")
            shift
            ;;
        esac
      done

      local effective_project_dir="${project_dir:-${SUPABASE_DIR}}"

      if [[ "$ensure_mode" == "auto" ]]; then
        case "$action" in
          apply|switch|reset)
            ensure_mode="true"
            ;;
          status)
            ensure_mode="false"
            ;;
        esac
      fi

      run_shared_action "$supabase_action" "$ensure_mode" "$effective_project_dir" "$skip_env_sync" "$project_env_file" "$project_ref" "${cli_args[@]}"
      ;;
    --help|-h|"")
      db_usage
      ;;
    *)
      die "Unknown db subcommand: ${action}"
      ;;
  esac
}

project_command() {
  local action="${1:-}";
  shift || true

  case "$action" in
    use)
      local skip_status="false"
      local project_input=""

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --skip-status)
            skip_status="true"
            shift
            ;;
          --help|-h)
            project_use_usage
            return 0
            ;;
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            if [[ -n "$project_input" ]]; then
              die "Project directory already provided: $project_input"
            fi
            project_input="$2"
            shift 2
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments after '--': $*"
            fi
            ;;
          --*)
            die "Unknown option for 'airnub project use': $1"
            ;;
          *)
            if [[ -n "$project_input" ]]; then
              die "Multiple project directories provided: '$project_input' and '$1'"
            fi
            project_input="$1"
            shift
            ;;
        esac
      done

      if [[ -z "$project_input" ]]; then
        die "Project directory is required. See 'airnub project use --help'."
      fi

      local resolved_project
      resolved_project="$(resolve_dir "$project_input")"

      env_command sync --project-dir "$resolved_project"
      db_command apply --project-dir "$resolved_project"
      if [[ "$skip_status" != "true" ]]; then
        db_command status --project-dir "$resolved_project"
      fi

      remember_project "$resolved_project"
      show_current_project
      ;;
    setup)
      local project_input=""
      local skip_env_sync="false"

      while [[ $# -gt 0 ]]; do
        case "$1" in
          --project-dir)
            [[ $# -lt 2 ]] && die "--project-dir requires a directory"
            if [[ -n "$project_input" ]]; then
              die "Project directory already provided: $project_input"
            fi
            project_input="$2"
            shift 2
            ;;
          --skip-env-sync)
            skip_env_sync="true"
            shift
            ;;
          --help|-h)
            project_setup_usage
            return 0
            ;;
          --)
            shift
            if [[ $# -gt 0 ]]; then
              die "Unexpected extra arguments after '--': $*"
            fi
            ;;
          --*)
            die "Unknown option for 'airnub project setup': $1"
            ;;
          *)
            if [[ -n "$project_input" ]]; then
              die "Multiple project directories provided: '$project_input' and '$1'"
            fi
            project_input="$1"
            shift
            ;;
        esac
      done

      local resolved_project=""
      if [[ -n "$project_input" ]]; then
        resolved_project="$(resolve_dir "$project_input")"
      else
        if ! resolved_project="$(get_current_project_dir)"; then
          die "No current project recorded. Use 'airnub project use <dir>' or supply --project-dir."
        fi
      fi

      local env_example="$resolved_project/.env.example"
      local env_local="$resolved_project/.env.local"

      if [[ -f "$env_example" ]]; then
        if [[ ! -f "$env_local" ]]; then
          cp "$env_example" "$env_local"
          echo "[airnub] Created $env_local from $env_example."
        else
          local appended_keys
          appended_keys="$(python3 - "$env_local" "$env_example" <<'PY'
import os
import sys

dest, example = sys.argv[1:3]

def load_keys(path):
    keys = {}
    if not os.path.exists(path):
        return keys
    with open(path, 'r', encoding='utf-8') as fh:
        for line in fh:
            stripped = line.strip()
            if not stripped or stripped.startswith('#'):
                continue
            if '=' not in line:
                continue
            key = line.split('=', 1)[0].strip()
            if key:
                keys.setdefault(key, line.rstrip('\n'))
    return keys

existing = load_keys(dest)
example_keys = load_keys(example)

missing = [k for k in example_keys.keys() if k not in existing]

if not missing:
    sys.exit(0)

needs_newline = False
if os.path.exists(dest) and os.path.getsize(dest) > 0:
    with open(dest, 'rb') as fh:
        fh.seek(-1, os.SEEK_END)
        needs_newline = fh.read(1) != b'\n'

with open(dest, 'a', encoding='utf-8') as fh:
    if needs_newline:
        fh.write('\n')
    for key in missing:
        fh.write(example_keys[key])
        fh.write('\n')

print('Added keys: ' + ', '.join(missing))
PY
)"
          if [[ -n "$appended_keys" ]]; then
            echo "[airnub] ${appended_keys}"
          else
            echo "[airnub] .env.local already contains keys from $env_example."
          fi
        fi
      else
        echo "[airnub] No .env.example found in $resolved_project; skipping example sync."
      fi

      if [[ "$skip_env_sync" != "true" ]]; then
        env_command sync --project-dir "$resolved_project"
      else
        echo "[airnub] Skipped Supabase env sync (per --skip-env-sync)."
      fi
      ;;
    current)
      if [[ $# -gt 0 ]]; then
        case "$1" in
          --help|-h)
            project_current_usage
            return 0
            ;;
          *)
            die "Unknown option for 'airnub project current': $1"
            ;;
        esac
      fi
      show_current_project
      ;;
    --help|-h|"")
      project_usage
      ;;
    *)
      die "Unknown project subcommand: ${action}"
      ;;
  esac
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 1
  fi

  local command="$1"
  shift

  case "$command" in
    env)
      env_command "$@"
      ;;
    db)
      db_command "$@"
      ;;
    project)
      project_command "$@"
      ;;
    use)
      project_command use "$@"
      ;;
    --help|-h)
      usage
      ;;
    *)
      die "Unknown command: $command"
      ;;
  esac
}

main "$@"
